## 一、UART

### 1.1 UART 帧格式讲解

通用异步收发器，**串行**，**异步**通信，两条数据线，可实现**全双工**的发送和接受

* 波特率：每秒传送的 bit 数量

![image-20230908100528393](通信协议.assets/image-20230908100528393.png)

> 为什么叫异步呢？
>
> 因为发送端和接受端各自恰着自己的时钟来对信号进行时分

> 为什么帧最多就传送 8 位？
>
> 因为是异步通信，会有一个累计误差，当累计误差达到一定程度就会导致后面的信号全部错位，短的帧更有利于减少误差带来的后果

> UART 从低位开始发送，比如要发送 101011 则发送顺序为 110101

### 1.2 硬件控制器

![image-20230908102408521](通信协议.assets/image-20230908102408521.png)

有用的就两个口 RXD 和 TXD

![image-20230908104207914](通信协议.assets/image-20230908104207914.png)

由于 COM3 的电平太小，容易受干扰，所以要接上 SP3232 来放大电压，实现更远的信号传送

**设置引脚功能的本质**

让引脚在芯片内部链接到某一个对应的控制器上

![image-20230908104516621](通信协议.assets/image-20230908104516621.png)

**寄存器的设置**

![image-20230908105708702](通信协议.assets/image-20230908105708702.png)

**串口控制器的工作逻辑**

```
The Baud-rate generator uses SCLK_UART.The transmitter and the receiver contain FIFOs and data shifters.The data to be transmitted is written to Tx FIFO, and copied to the transmit shifter. The data is then shifted out bythe transmit data pin (TxDn). The received data is shifted from the receive data pin (RxDn), and copied to Rx FIFOfrom the shifter.

移位器把队列缓冲区的数据拷贝走，然后加上起始位，停止校验位等，从 TX 引脚发送出去
```

![image-20230908111351228](通信协议.assets/image-20230908111351228.png)

### 1.3 UART 寄存器详解

![image-20230908131121471](通信协议.assets/image-20230908131121471.png)

**ULCONn**

![image-20230908131202559](通信协议.assets/image-20230908131202559.png)

设置帧的格式（红外模式，普通模式，校验位，停止位，数据长度）

**UCONn**

![image-20230908132450403](通信协议.assets/image-20230908132450403.png)

主要是设置发送模式和接受模式

* 轮询模式

cpu 每过一段时间就去查看缓冲队列里有没有数据，如果有则进行拷贝等操作

* 中断模式

当有新数据产生，则向 cpu 发送中断，然后 cpu 再对缓存队列进行拷贝等操作

* DMA 模式

直接将数据放到指定的内存当中

**UTRSTAT**

串口通信时的一些状态寄存器（判断串口是否发送完成等）

**UTXHn & URXHn**

![image-20230908134243897](通信协议.assets/image-20230908134243897.png)

将发送的数据写到这个寄存器，发送器会将该数据发送出去 

**UBRDIVn & UFRACVALn**

![image-20230908134420165](通信协议.assets/image-20230908134420165.png)

设置波特率分频值寄存器（小数部分和整数部分）

### 1.4 UART 大致流程

```c
void UART_Send_Byte(char dat)
{
    /* 将要发送的数据写入发送寄存器 UTXH2 */
    while(!(UART2.UTRStAT2 & (1 << 1))); // 读取状态寄存器
    UART2.UTXH2 = dat;    
}

char UART_Rec_Byte(void)
{
    char dat = 0;
    /* 判断是否接受到了数据 */
    if(UART2.UTRSTAT2 & (1 << 0)){
        dat = UART2.URXH2;
        return dat;
    }else{
        return 0;
    }
}

void UART_Init()
{
    /* 将 GPA1_0 和 GPA1_1 分别复用成 UART2 的接受和发送引脚 GPA1CON[7:0] */
    GPA1.CON = GPA1.CON & (~(0xff << 0)) | (0x22 << 0);
    /* 设置帧格式 ULCON2 8 位数据 1 位停止位 无校验 正常模式 */
    UART2.ULCON2 = UART2.ULCON2 & (~(0x7f) << 0) | (0x3 << 0);
    /* 设置 UART2 的接受和发送模式为轮询模式 UCON2[3:0] */
    UART2.UCON2 = UART2.UCON2 & (~(0xf) << 0) | (0x5 << 0);
    /* 设置 UART2 的波特率为 115200 UBRDIV2/UFRACVAL2 */
    UART2.UBRDIV2 = 53;
    UART2.UFRACVAL2 = 4;    
}

int main()
{
    char RecDat = 0;
	UART_Init();
    while(1){
		RecDat = UART_Rec_byte();
        if(!RecDat){
            
        }else{
            RecDat ++;
            UART_Send_byte(RecDat);
        }
    }
    return 0;
}
```

### 1.5 输入输出重定向

将输出重定向到串口（linux 中调用 c 库的 printf 函数可以将输出重定向到显卡然后在屏幕显示）

```c
void UART_Send_Str(char * pstr)
{
    while(*pstr != '\0')
	    UART_Send_Byte(*pstr++);
}

int main()
{
	UART_Init();
    while(1){
		UART_Send_Str("hello world\n\r");
    }
    return 0;
}
```

* linux 中的用法

```c
ls > a.txt
```

## 二、RS232、RS485 协议原理与应用

**串口存在的问题**

* 电气接口不统一

只是对信号的时序进行了定义，未定义接口的电气特性（高电平表示1，但是多少伏不知道，没有统一标准）

* 抗干扰能力差

使用 TTL 表示 0 和 1 ，在传输过程中容易出错

* 通信距离极短

因为抗干扰能力差，所以其通信距离也很短

**RS232 协议**

串口的一种标准（一般只用 RXD TXD GND）

* 接口统一（左边 232 右边 485）

![](https://img2.baidu.com/it/u=3534447493,4287354210&fm=253&fmt=auto&app=138&f=JPEG?w=806&h=500)

* 信号统一

规定 '1' 为 -5 ~ -15，规定 '0' 为 +5 ~ +15，电平高，传输距离能达到 15 m

**232 的电平转换**

![image-20230909115058834](通信协议.assets/image-20230909115058834.png)

将 TTL 转成 232 信号，然后从 com 发出，或将 com 得到的 232 信号转成 TTL 给芯片

**232 存在的问题**

![image-20230909115739943](通信协议.assets/image-20230909115739943.png)

**RS485 协议**

与 232 相比，具有多站能力，可以组成局域网多对多通信。传输距离长(1500m)，抗噪声能力大，接口信号电平比 232 低，不易损坏接口

![image-20230909120552446](通信协议.assets/image-20230909120552446.png)

* 接口统一

![](https://pic.rmb.bdstatic.com/bjh/down/a85892cd00c2626267427fa0244404fa.jpeg)

* 信号统一

采用差分信号进行数据传输，两线间信号差 +2 到 +6 表示 1；-2 到 -6 表示 0

**485 的电平转换**

![image-20230909134003169](通信协议.assets/image-20230909134003169.png)

**485 的问题**

采用两线制，所以发送和接受都采用这两根线，只能采用**半双工**的方式工作,写代码的时候就要做出相应改变

## 三、IIC

### 3.1 IIC 总线概述

串行，半双工，近距离，低速，两根线，SDA 用于收发数据，SCL 用于同通信时钟

**IIC 总线协议**

![image-20230909175957867](通信协议.assets/image-20230909175957867-16942535983611.png)

这么多机器分为主机和从机，主机有权发起和结束一次通信，从机只能被动呼叫。每个连接到 IIC 总线上的器件都有一个唯一的地址（7bit）每个器件都能作为主机和从机（同一时间只能有一个主机）

**IIC 总线的通信过程**

![image-20230909181312271](通信协议.assets/image-20230909181312271.png)

这里从机的地址是 7 位，一个字节 8 位，所以最后一位是后续字节数据的传送方向。（注意，这里后续字节的数据的传送方向会重新决定主机和从机）

* 若为 0 表示主 -> 从
* 若为 1 表示 从 -> 主

发送器发送一个字节的数据（这里可以是从机发送或者主机发送，取决于 0 或者 1）接收器也是同理。

```txt
主机在发送起始信号后，必须先发送一个字节的数据，数据的高7位是从机的地址，最后一位是后续字节的传送方向，其中 0 表示主机发送数据（主机为发送器），1 表示从机发送数据（从机为发送器），总线上所有的从机接受到该字节数据后将高7位地址与字节的地址进行比较，如果相同则认为自己被主机寻址，最后再根据最后一位确定自己是发送器还是接受器。
```

### 3.2 IIC 总线信号实现

空闲时，两条线为高电平

**起始信号和停止信号**

* SCL 为高电平时，SDA由高变低表示起始信号
* SCL 为高电平时，SDA由低变高表示停止信号

起始信号和停止信号由主机发出，起始信号产生后总线处于占用状态，停止信号发出后总线处于空闲状态

**字节传送与应答**

通信时每个字节为 8 位，发送顺序是从高到低（UART 是从低位到高位）发送器发送完一个字节后接收器必须发送 1 位应答位来回应发送器

![image-20230910104306393](通信协议.assets/image-20230910104306393.png)

**同步信号**

首先所有的设备都是链接在同一条时钟线上的，也就是说所有的设备的时钟都是同步的。当时钟为低位时，发送器向总线上发送一位数据，在此期间数据线上的信号允许发生变化；当时钟为高位时，接收器从数据线上读取一位数据，在此期间数据线上的数据不允许发生变化，必须保持稳定

![image-20230910105846831](通信协议.assets/image-20230910105846831.png)

### 3.3 典型 IIC 时序

![image-20230910111921825](通信协议.assets/image-20230910111921825.png)

![image-20230910111932046](通信协议.assets/image-20230910111932046.png)

![image-20230910112604120](通信协议.assets/image-20230910112604120.png)

这里主机想要发起下一次的开始信号之前，并没有发送停止信号释放总线（防止被其他主机占用）

![image-20230910112613029](通信协议.assets/image-20230910112613029.png)

### 3.4 Exynos4412 下的 IIC 控制器

**特点**

![image-20230910155336969](通信协议.assets/image-20230910155336969.png)

**工作逻辑**

![image-20230910155355509](通信协议.assets/image-20230910155355509.png)

* 将数据放到 I2CDS 寄存器中，然后会将 I2CDS 寄存器中的数据拷贝到移位寄存器中，然后移位寄存器通过 SDA 数据总线把数据发送出去。
* 作为从机时，把地址放到 Address 寄存器，并比较

**程序编写流程图**

主机发送模式：

![image-20230910160608975](通信协议.assets/image-20230910160608975.png)

```c
解释：
    首先配置寄存器为 Master Yx 模式，将从机的地址写入 I2CDS 寄存器中，然后写下 0xF0 到 I2CSTAT 寄存器中，表示开始信号的产生。  
    然后 I2CDS 的数据被发送（地址），等待得到应答之前，中断挂起。
    如果收到应答，可以选择是否停止，如果不停止，则继续将数据写到 I2CDS ，清除应答位，然后数据发送出去，然后等待应答。得到应答之后，如果要停止，则写下 0xD0 到 I2CSTAT 表示停止信号产生，然后清除应答位，等待停止即可。
```

主机接收模式：

![image-20230910163506414](通信协议.assets/image-20230910163506414.png)

```c
解释：
    前面的步骤和上面一样，发送从机地址，建立连接。
    如果不停止，则直接往 I2CDS 中读取数据，这个数据是从机发过来的。读完之后清除挂起位，这时又有数据从 SDA 总线中传送到 I2CDS 寄存器里。然后中断挂起。
    如果要停止，则写 0x90 到 I2CSTAT 中，并清除挂起位，等待结束。
```

从机发送模式：

![image-20230910165656390](通信协议.assets/image-20230910165656390.png)

从机接收模式：

![image-20230910165709982](通信协议.assets/image-20230910165709982.png)

### 3.5 IIC 寄存器详解

**寄存器总览**

![image-20230910171901259](通信协议.assets/image-20230910171901259.png)

最后一个不常用，应用于滤波器和延时相关的。

**I2CCONn**

![image-20230910173542994](通信协议.assets/image-20230910173542994.png)

**I2CSTATn**

![image-20230910173658217](通信协议.assets/image-20230910173658217.png)

**I2CADDn**

![image-20230910175346580](通信协议.assets/image-20230910175346580.png)

**I2CDSn**

![image-20230910175400475](通信协议.assets/image-20230910175400475.png)

### 3.6 MPU6050 原理

MPU6050 是一个运动处理传感器，内部集成了 3 轴加速度传感器和 3 轴陀螺仪（角速度传感器），以及一个可扩展数字运动处理器

**主要参数**

![image-20230910203830448](通信协议.assets/image-20230910203830448.png)

**通信接口**

可以使用 IIC 总线和其他器件进行数据交互。

![image-20230910204308898](通信协议.assets/image-20230910204308898.png)

### 3.7 MPU6050 寄存器读写时序

MPU6050 在 IIC 通信中是作为从机使用的。

![image-20230911164212560](通信协议.assets/image-20230911164212560.png)

![image-20230911170333005](通信协议.assets/image-20230911170333005.png)

读有两步，需要先写，告诉 mpu6050 要读什么，然后再读，mpu6050 写

## 四、SPI 总线

**连接过程**

![image-20230912174927725](通信协议.assets/image-20230912174927725.png)

**通信过程**

先传送高位，再传送低位。高电平为 1 ，低电平为 0 。接收方无需应答。

SPI 下降沿发送数据，上升沿接收数据

**极性 CPOL 和相位 CPHA**

CPOL 表示 SCLK 空闲时的状态：

* CPOL = 0 空闲时 SCLK 为低电平
* CPOL = 1 空闲时 SCLK 为高电平

CPHA 表示采样时刻：

* CPHA = 0 每个周期的第一个时钟沿采样
* CPHA = 1 每个周期的第二个时钟沿采样

![image-20230914133844053](通信协议.assets/image-20230914133844053.png)

![image-20230914133934240](通信协议.assets/image-20230914133934240.png)

![image-20230914134057073](通信协议.assets/image-20230914134057073.png)

![image-20230914134131712](通信协议.assets/image-20230914134131712.png)

**IIC 和 SPI 的异同**

相同点：

* 均采用串行、同步的方式
* 均采用 TTL 电平，传输距离和应用场景类似
* 均采用主从方式工作

不同点：

* IIC 为半双工，SPI 为全双工
* IIC 有应答机制，SPI 无应答机制
* IIC 通过向总线广播从机地址来寻址，SPI通过向对应从机发送片选信号
* IIC 的时钟极性和时钟相位固定， SPI 的时钟极性和时钟相位可改变

## 五、网络编程

### 5.1 网络模型与协议介绍

**OSI 七层模型与 TCP/IP 四层模型：**

![image-20230923225744069](通信协议.assets/image-20230923225744069.png)

OIS 七层模型：”物数网传会表应“

TCP/IP 四层模型

应用层：http、ftp、nfs、ssh、telnet ...

传输层：TCP、UDP

网络层：IP、ICMP、IGMP

链路层：以太网帧协议、ARP、MAC 帧

**以太网帧和 ARP 请求：**

网络传输过程：

数据没有封装之前是不能在网络上传输的

ARP协议：

通过 IP 地址获取 MAC 地址

以太网帧协议：

根据 mac 地址寻找下一跳的位置，从而完成数据包传输，

**IP 协议（网络层）：**

![image-20230924112434091](通信协议.assets/image-20230924112434091.png)

版本：IPv4、IPv6

TTL：time to live 设置数据包在路由节点中的跳转上限，每经过一个节点该值 -1 当减为 0 时，路由有义务将该数据报丢弃

源 IP 和目的 IP：32位	192.168.1.108 点分十进制 IP 地址（string）--计算机看是二进制来看的

**TCP 协议（传输层）：**

![image-20230924114204637](通信协议.assets/image-20230924114204637.png)

16位：源端口号

16位：目的端口号

32 序号

32 确认序号

6 标志位

16 窗口大小 2^16 = 65535

**C/S 模型和 B/S 模型：**

* client-server

优点：缓存大量数据（客户端内带大量数据），协议选择上灵活（可以自定义协议），速度快

缺点：安全性差，开发工作量大

* browser-server

优点：安全性好，可以跨平台，开发工作量较小

缺点：不能缓存大量数据，必须要严格遵守 http 协议

### 5.2 Socket 套接字编程

**Socket 套接字：**

网络套接字：socket

IP 地址+端口号对应一个 socket

在通信过程中套接字一定是成对出现的

![image-20230924120307244](通信协议.assets/image-20230924120307244.png)

一个文件描述符里有两个缓冲区指向一个套接字，一个管道运输

**网络字节序：**

小端法：高位高地址，低位存低地址

大端法：高位存低地址，低位存高地址

TCP/IP 协议规定网络数据流应该采用大端字节序。

调用以下函数进行网络字节序和主机字节序的转换

```c
#include <arpa/inet.h>
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
```

>h -> host to n -> net l -> long 32 位
>
>htonl 和 htons 本地字节序转网络字节序
>
>ntohl 和 ntohs 网络字节序转本地字节序

**IP 地址转换函数：**

```c
# include <arpa/inet.h>
/* 本地字节序(string) 转换成网络字节序的 ip*/
int inet_pton(int af, const char *src, void *dst);

af: AF_INET AF_INET6
src: IP地址（点分十进制）
dst: 传出转换后的网络字节序的IP地址    
返回: 成功: 1 异常: 0	失败: -1

/* 网络字节序转换成本地字节序(string)的 ip*/    
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
返回值: 成功 非空 char * 失败 NULL
```

**sockaddr 数据结构：**

```c
struct sockaddr_in {
	sa_family_t;
    in_port_t;
    struct in_addr sin_addr; 
};
struct sockaddr_i addr;
addr.sin_family = AF_INET/AF_INET6
addr.sin_port = htons(9527);
int dst;
addr.sin_addr.s_addr = inte_pton(AF_INET, "192.157.22.45", (void *)&dst);
【*】addr.sin_addr.s_addr = ADDRIN_ANY;// 取出系统中有效的任意IP地址,二进制类型
bind(fd, (struct sockaddr *)&addr, size);
```

socket 模型创建流程图

![image-20230924165059693](通信协议.assets/image-20230924165059693.png)

* 服务端：

bind 绑定 IP + port

listen 设置监听上限（设置同时与服务器建立连接的数量）

accept 阻塞监听客户端连接

建立连接之后，分配新的 socket 来进行通信，本 socket 继续去阻塞监听新的连接

* 客户端：

connect 

**socket 函数**

```c
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
/*
domain: AF_INET/AF_INET6/AF_UNIX
type: 创建套接字指定数据传输协议（流式和报式） SOCK_DGRAM/SOCK_STREAM
protocol: 0
返回值: 成功 返回新套接字所对应的文件描述符 失败返回 -1
*/
```

**bind 函数**

```c
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
/*
sockfd: socket 函数返回值
struct sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_port = htons(8888);
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
addr: (struct sockaddr *)&addr
addrlen: sizeof(addr) 地址结构的大小
返回值: 成功 0 失败 -1    
```

**listen 函数**

设置同时与服务器建立连接的上限数（同时进行 3 次握手的客户端数量）

```c
int listen(int sockfd, int backlog);
/*
sockfd: socket 函数返回值
backlog: 上限数值，最大值 128
返回值: 成功 0 失败 -1
*/
```

**accept 函数**

阻塞等待客户端建立连接，成功返回一个与客户端成功连接的 socket 文件描述符

```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
/*
sockfd socket 函数返回值
addr 传出参数，成功与服务器建立连接的客户端的地址结构 （ip + port）
addrlen 入: addr的大小  出: 客户端addr实际的大小
成功 返回能与服务器进行数据通信的文件描述符
*/
```

**connect 函数**

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
/*
sockfd: socket 函数返回值
addr: 传入参数 服务器的地址结构
addrlen 服务器地址结构的长度
成功 返回 0 失败返回 -1
*/
```

如果不使用 band 绑定客户端地址结构，采用隐式绑定

### 5.3 TCP 通信流程

#### 5.3.1 TCP 通信流程分析

* server:

```c
socket()	创建 socket
bind()	绑定服务器的地址结构
listen()	设置最大同时接受监听数
accept()	阻塞并等待客户端监听
read(fd) 读 socket 获取客户端数据
小写->大写 toupper()
write(fd) 写回去
close()
```

* client:

```c
socket() 创建 socket
connect() 与服务器建立连接
write() 写数据到服务器
read() 读转换后的数据
显示读取结果
close()
```

#### 5.3.2 客户端与服务端的 sock 通信代码

client.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <ctype.h>

#include <sys/socket.h>
#include <arpa/inet.h>

#define SERV_PORT 9527

/* 出错函数 */
void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

int main(int argc, char *argv[])
{
    int cfd;
    int ret;
    int i = 20;
    char buf [4096];
    struct sockaddr_in server_addr; // 服务器地址结构
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERV_PORT);
    // server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr.s_addr);

    cfd = socket(AF_INET, SOCK_STREAM, 0);
    if(cfd == -1) {
        sys_err("sock error");
    }
    ret = connect(cfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
    if(ret == -1) {
        sys_err("connect error");
    }
    while(i--) {
        write(cfd, "sdoih3*&p/", 11);
        ret = read(cfd, buf, sizeof(buf));
        write(STDOUT_FILENO, buf, ret);
    }
    close(cfd);
    exit(0);
}
```

server.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <ctype.h>

#include <sys/socket.h>
#include <arpa/inet.h>

#define SERV_PORT 9527
#define BUFFSIZE 4096
/* 出错函数 */
void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

int main(int argc, char *argv[])
{
    int lfd = 0; // 用于接待的fd
    int sfd = 0; // 建立连接之后的fd

    int i; // 循环
    int ret = 0; // 返回值判断
    char buf[BUFFSIZE]; // 读缓冲区 一个char一个字节
    char client_ip[BUFFSIZE]; // 客户端IP
    struct sockaddr_in serv_addr, clit_addr; // 定义服务器和客户端的ip结构
    socklen_t clit_addr_len;

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(SERV_PORT);
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    /* 创建 Socket */
    lfd = socket(AF_INET, SOCK_STREAM, 0);
    if(lfd == -1) {
        sys_err("socket error");
    }
    /* 绑定 bind */
    ret = bind(lfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    if(ret == -1) {
        sys_err("bind error");
    }
    /* 设置 listen */
    ret = listen(lfd, 128);
    if(ret == -1) {
        sys_err("listen error");
    }
    /* 阻塞等待客户端连接 */
    clit_addr_len = sizeof(clit_addr);
    sfd = accept(lfd, (struct sockaddr *)&clit_addr, &clit_addr_len);
    if(sfd == 0) {
        sys_err("accept error");
    }
    printf("client ip:%s port:%d\r\n"
        , inet_ntop(AF_INET, &clit_addr.sin_addr.s_addr, (void *)&client_ip, sizeof(client_ip))
        , ntohs(clit_addr.sin_port));

    while(1) {
        /* 读操作 */
        ret = read(sfd, buf, sizeof(buf)); // 返回读到的字节数
        write(STDOUT_FILENO, buf, ret); // 打印一下读到的内容

        for(i = 0; i < ret; i++) {
            buf[i] = toupper(buf[i]);
        }
        /* 写操作 */
        write(sfd, buf, ret);
    }
    close(lfd);
    close(sfd);
    exit(0);
}
```

#### 5.3.3 作业--聊天室

假设：所有客户端不退出，但是中途可以加入

客户端功能描述：

* 输入 `l` 查看当前聊天室的所有信息，包括：
  * 第几号客户端
  * ip地址
  * 端口号
* 输入 `n [数字编号]` 切换成要发送的客户端，并进入发送模式
* 输入 `s` 切换成群发，并进入发送模式
* 输入 `r` 切换成接收模式
* 输入`:q`退回上一级

服务端功能描述：

* 能够及时返回当前聊天室信息列表给客户端
* 能够转发客户端的信息给指定客户端

**方案一(失败)**

使用单个线程循环遍历每个 sfd ，但是由于 sock 会阻塞到 read 函数上，所以无法实现，设置了 socknoblock 也没有效果

**方案二**

服务器端每个线程管理一个 sock ，从而实现非阻塞通信

代码：

client.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <ctype.h>

#include <sys/socket.h>
#include <arpa/inet.h>

#define SERV_PORT 11451 // 服务器端口
#define BUFSIZE 4096 // 缓冲区字节数

int back = 0;
int cfd;
char read_buf[BUFSIZE];

/* 出错函数 */
void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

/* 接受sock信息 */
void *recv_info(void *arg)
{
    int ret;
    while(1) {
        ret = read(cfd, read_buf, sizeof(read_buf));
        if(ret != 0) {
            write(STDOUT_FILENO, read_buf, ret);
        }
    }
}

int main()
{
    pthread_t pthid; // 
    /* 初始化服务器地址结构 */
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERV_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    int ret;
    int i;
    char ctrl_buf[BUFSIZE];

    /* sock 创建客户端文件描述符 */
    cfd = socket(AF_INET, SOCK_STREAM, 0);
    if(cfd == -1) {
        sys_err("sock error");
    }
    /* connect 建立连接 */
    ret = connect(cfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
    if(ret == -1) {
        sys_err("connect error");
    }
    printf("服务器连接成功!!!\r\n");

    /* 建立子线程用于随时接受信息 */
    ret = pthread_create(&pthid, NULL, recv_info, NULL);
    if(ret != 0) {
        sys_err("thread create error");
    }    

    while(1) {

        printf("欢迎使用聊天室，功能如下: \r\n");
        printf("'l' 查看当前聊天室信息\r\n");
        printf("'s' 切换成群发模式\r\n");
        printf("'n[客户端编号]' 切换成指定发送模式\r\n");
        printf(":q 返回上一级\r\n");
        read(STDIN_FILENO, ctrl_buf, sizeof(ctrl_buf));
        switch(ctrl_buf[0]) {
        int save_fd;  
        char write_buf[BUFSIZE];          
        case 'l':
            printf("打印聊天室信息\r\n");
            write(cfd, ctrl_buf, sizeof(ctrl_buf)); 
            break;
        case 's': 
            while(1) {
                printf("请输入群发信息(:q退出):\r\n");
                ret = read(STDIN_FILENO, write_buf, sizeof(write_buf));
                if(write_buf[0] == ':' && write_buf[1] == 'q') {
                    break;
                }
                // 将缓存向后移动一位
                for(i = ret-1; i >= 0; i--) {
                    write_buf[i+1] = write_buf[i];
                }
                write_buf[0] = 's';
                write(cfd, write_buf, ret+1); 
            }
            break;
        case 'n': 
            while(1) {
                printf("请输入发送给客户端[%c]的信息(:q退出)\r\n", ctrl_buf[1]);
                ret = read(STDIN_FILENO, write_buf, sizeof(write_buf));
                if(write_buf[0] == ':' && write_buf[1] == 'q') {
                    break;
                }
                // 将缓存向后移动两位
                for(i = ret-1; i >= 0; i--) {
                    write_buf[i+2] = write_buf[i];
                }
                write_buf[0] = 'n';
                write_buf[1] = ctrl_buf[1];
                write(cfd, write_buf, ret+2); 
            }        
            break;            
        }

    }

    pthread_join(pthid, NULL);
    if(ret != 0) {
        sys_err("thread join error");
    }
    exit(0);

}
```

server.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <ctype.h>

#include <sys/socket.h>
#include <arpa/inet.h>
#include <signal.h>

#define SERV_PORT 11451 // 服务器端口
#define BUFSIZE 4096 // 缓冲区字节数
#define MAX_LISTEN 128 // 最大同时监听数
#define MAX_CONNECT 9 // 最大连接客户端数量

int sfd[128]; // 用于通信的文件描述符
int lfd; // 接待文件描述符
int connect_count = 0; // 当前的连接数

struct sockaddr_in client_addr[MAX_CONNECT]; // 定义客户端的地址结构数组
socklen_t client_addr_len[MAX_CONNECT]; // 定义客户端的地址结构长度数组
char client_ip[MAX_CONNECT][32]; // 定义客户端的ip

/* 出错函数 */
static void sys_err(const char *str)
{
    perror(str);
    exit(1);
}

/* 将数据去掉头n个字节 */
static void del_head_char(int n, char *buf, int length)
{
    int i = 0;
    for(i = 0; i < length-n; i++) {
        buf[i] = buf[i+n];
    }
    buf[length-n] = '\0';
}

/* 终止信号处理函数 */
static void sig_handler()
{
    int i;
    printf("服务器中断\r\n");
    /* 关闭文件 */
    for(i = 0; i < connect_count; i++) {
        close(sfd[i]);
    }
    close(lfd);
    exit(0);    
}

/* 转发函数 */
static void *transmit_thread_start(void *arg)
{
    char read_buf[BUFSIZE];
    int sock_index = *(int *)arg;
    int ret;
    int i;
    printf("transmit_thread start id [%lu] socket index[%d]\r\n", pthread_self(), sock_index);
    while(1) {
        // 从socket读取数据
        ret = read(sfd[sock_index], read_buf, sizeof(read_buf));
        if(ret > 0) {
            printf("read_buf的数据：%s", read_buf);
            switch(read_buf[0]) {
            int save_fd;
            case 'l':  // 打印聊天室信息
                save_fd = dup(STDOUT_FILENO);
                dup2(sfd[sock_index], STDOUT_FILENO);
                for(i = 0; i < connect_count; i++) {
                    printf("编号[%d] IP地址[%s] 端口[%d]\r\n", i
                        , inet_ntop(AF_INET, &client_addr[i].sin_addr.s_addr, (void *)&client_ip[i], sizeof(client_ip[i]))
                        , ntohs(client_addr[i].sin_port));
                }
                dup2(save_fd, STDOUT_FILENO);   
                break;
            case 's':  // 群发消息
                del_head_char(1, read_buf, ret); // 将数据去掉头1个字节   
                for(i = 0; i < connect_count; i++) {
                    // 重定向printf到socket文件描述符        
                    save_fd = dup(STDOUT_FILENO);
                    dup2(sfd[i], STDOUT_FILENO);
                    printf("群发-> %s", read_buf);
                    dup2(save_fd, STDOUT_FILENO);
                }              
                break;
            case 'n':  // 指定发送消息
                    char c_num = read_buf[1];
                    int num = atoi(&c_num); // 保持编号
                    del_head_char(2, read_buf, ret); // 将数据去掉头2个字节
                    save_fd = dup(STDOUT_FILENO);
                    dup2(sfd[num], STDOUT_FILENO);
                    printf("客户端[%d]-> %s", sock_index, read_buf);
                    dup2(save_fd, STDOUT_FILENO);                
                break;
            }
        }
        /* 清空缓存 */
        for (unsigned int i = 0; i < ret; i++) {
            read_buf[i] = '\0'; 
        }
    }
    pthread_exit((void *)0);
}

int main()
{
    int ret = 0;
    int i = 0;

    pthread_t transmit_thread[MAX_CONNECT]; // 线程id
    void *pthret[MAX_CONNECT]; // 线程返回值

    /* 处理终止信号 ctrl+c*/
    __sighandler_t sig_ret;
    sig_ret = signal(SIGINT, sig_handler);
    if(sig_ret == SIG_ERR) {
        sys_err("signal error");
    }

    /* 初始化服务器地址结构 */
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERV_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    /* sock 创建接待文件描述符 */
    lfd = socket(AF_INET, SOCK_STREAM, 0);
    if(lfd == -1) {
        sys_err("socket error");
    }
    /* bind 绑定服务器的地址结构 */
    ret = bind(lfd, (struct sockaddr *)&server_addr, sizeof(server_addr));
    if(ret == -1) {
        sys_err("bind error");
    }
    /* listen 设置监听 */
    ret = listen(lfd, MAX_LISTEN);
    if(ret == -1) {
        sys_err("listen error");
    }
    /* 阻塞等待连接 */
    for(i = 0; i < MAX_CONNECT; i++) {
        client_addr_len[i] = sizeof(client_addr[i]);
        sfd[i] = accept(lfd, (struct sockaddr *)&client_addr[i], &client_addr_len[i]);
        if(sfd[i] == -1) {
            sys_err("accept error");
        }
        /* 创建子线程用于转发客户端的信息 */
        ret = pthread_create(&transmit_thread[i], NULL, transmit_thread_start, &i); // 参数   
        if(ret != 0) {
            sys_err("create thread error");
        }
        printf("client[%d] connet success!\r\n", i);
        printf("client ip[%s] port[%d]\r\n"
            , inet_ntop(AF_INET, &client_addr[i].sin_addr.s_addr, (char *)&client_ip[i], sizeof(client_ip[i]))
            , ntohs(client_addr[i].sin_port));
        connect_count++;   
        sleep(1);
    }

    /* 等待子线程结束 */
    for(i = 0; i < connect_count; i++) {
        ret = pthread_join(transmit_thread[i], &pthret[i]);
        if(ret != 0) {
            sys_err("join thread error");
        }     
    }

    /* 关闭文件 */
    for(i = 0; i < connect_count; i++) {
        close(sfd[i]);
    }
    close(lfd);

}
```









